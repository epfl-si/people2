# frozen_string_literal: true

class ApplicationController < ActionController::Base
  around_action :switch_locale

  # Enable url method on active storage blobs for now we desist. We will make
  # image links invalid by rotating the SECRET_KEY_BASE.
  # (e.g. profile.photo.available_image.variant(:medium2).processed.url)
  include ActiveStorage::SetCurrent

  include Authentication
  include Flashable

  def self.unique_counter_value
    @indx ||= 0
    @indx += 1
    @indx
  end

  # see https://guides.rubyonrails.org/i18n.html#setting-the-locale-from-url-params
  # this will add the current local to all urls generated by route helpers. It
  # will work also if we use a path scope instead of a query parameter for locale
  def default_url_options
    { lang: I18n.locale }
  end

  def compute_audience(sciper)
    # keepting @audience because Current is not visible from the console thread
    @audience =
      if authenticated?
        if Current.user.sciper == sciper
          AudienceLimitable::OWNER
        else
          AudienceLimitable::AUTENTICATED
        end
      elsif intranet_client?
        AudienceLimitable::INTRANET
      else
        AudienceLimitable::WORLD
      end
    Current.original_audience = @audience
    Current.audience = @audience
    return @audience unless (fe = Rails.configuration.force_audience)

    @audience = [[AudienceLimitable::WORLD, fe.to_i].max, AudienceLimitable::OWNER].min
    Current.audience = @audience
  end

  def current_user
    Current.user
  end

  def info_for_paper_trail
    # need to call authenticated? for the session to load
    as = authenticated? ? current_user&.sciper : nil
    { ip: request.remote_ip, author_sciper: as }
  end

  private

  def load_and_authorize_profile
    @profile ||= Profile.find(params[:profile_id])
    authorize! @profile, to: :update?
  end

  # This is for situation that should not arrive. In case, we want to provide
  # meaningful output in all formats.
  def unexpected(message)
    respond_to do |format|
      format.html do
        render inline: "<p><%= message %></p>", status: :forbidden
      end
      format.turbo_stream do
        flash.now[:error] = message
        render turbo_stream: turbo_stream.replace("flash-messages", partial: "shared/flash")
      end
      format.json { render json: { msg: message }, status: :forbidden }
    end
  end

  # TODO: this is intended for larger notifications than just the flash.
  #       We have to implement a larger dismissable popup box or recycle the
  #       one for editing or an identical one with dismiss button by default.
  def notifier(message)
    respond_to do |format|
      format.html do
        render inline: "<p><%= message %></p>"
      end
      format.turbo_stream do
        flash.now[:info] = message
        render turbo_stream: turbo_stream.replace("flash-messages", partial: "shared/flash")
      end
      format.json { render json: { msg: message } }
    end
  end

  def force_profile_locale(profile = @profile)
    return if profile.blank?

    l = I18n.locale

    tt = profile.translations
    redirect_to url_for(params.permit!.to_h.merge(lang: tt.first)) unless tt.include?(l)
    Current.available_locales = tt
  end

  # TODO: this part is terrible!
  # Trying to find a way to have a locale as close as possible to user choice
  # and a fallback locale that will be used by Translatable objects to provide
  # content in another available locale when not available in the main locale
  # This will result in mixed language profile pages but we consider this
  # better than having many blank parts.
  def switch_locale(&action)
    locale = (locale_from_param || locale_from_http_header || request_default_locale || I18n.default_locale).to_sym

    # Current.available_locales is normally identical to I18n.available_locales
    # except when user's profile are displayed. In which case, the choice is
    # reduced to respect the user preference with "force_profile_locale"
    Current.available_locales = I18n.available_locales
    Current.primary_lang = locale.to_s
    Current.gender = nil
    I18n.with_locale(locale, &action)
  end

  def locale_from_param
    return nil if params[:lang].blank?

    params[:lang]&.gsub(/[^a-zA-Z]/, '')&.to_sym
  end

  def locale_from_http_header
    al = request.get_header("HTTP_ACCEPT_LANGUAGE")
    return nil if al.blank?

    l = al.scan(/^[a-z]{2}/).first
    return unless l.present? && I18n.available_locales.include?(l = l.to_sym)

    l
  end

  # The first time it just resets the timer, subsequet calls write DT since first & last call
  def timelog(msg = "")
    unless defined?(@timelog_start_time)
      @timelog_start_time = @timelog_last_time = Time.zone.now
      return
    end

    t = Time.zone.now
    Rails.logger.debug("TIME: #{t - @timelog_start_time} #{t - @timelog_last_time} <- #{msg}")
    @timelog_last_time = t
  end

  # override if default locale needs to change (e.g. during profile editing)
  def request_default_locale
    nil
  end

  def intranet_client?
    request.get_header("HTTP_X_EPFL_INTERNAL")&.downcase == 'true'
  end

  # Overridden to selectively enable the debugger page in development,
  # depending on `exception`, if Rails.configuration.x.dwim_error_pages
  # is set.
  def rescue_with_handler(exception)
    return super if Rails.configuration.x&.dwim_error_pages.blank?

    http_status = ActionDispatch::ExceptionWrapper.status_code_for_exception(exception.class.name)
    want_web_debugger = want_web_debugger? exception, http_status

    rescue_how = want_web_debugger ? 'with the debugger' : 'with the normal error page'
    logger.error("rescue_with_handler: processing #{exception} exception #{rescue_how}")

    request.env["action_dispatch.show_detailed_exceptions"] = true if want_web_debugger

    super
  end

  def want_web_debugger?(_exception, http_status)
    http_status == 500
  end
end
